#ifndef MMTK_H
#define MMTK_H

/* Warning, this file is autogenerated by cbindgen from the mmtk-ruby repository. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

typedef struct MMTk_Builder MMTk_Builder;
typedef struct MMTk_Mutator MMTk_Mutator;

struct rb_thread_struct;
typedef struct rb_thread_struct rb_thread_t;
typedef rb_thread_t *MMTk_VMThread;
typedef rb_thread_t *MMTk_VMMutatorThread;
typedef struct MMTk_GCThreadTLS *MMTk_VMWorkerThread;
typedef void *MMTk_Address;
typedef void *MMTk_ObjectReference;
typedef void *MMTk_NullableObjectReference;
typedef uint32_t MMTk_AllocationSemantics;


#define MMTk_OBJREF_OFFSET 8

#define MMTk_MIN_OBJ_ALIGN 8

#define MMTk_GC_THREAD_KIND_WORKER 1

typedef struct MMTk_st_table MMTk_st_table;

typedef struct MMTk_RubyBindingOptions {
    bool ractor_check_mode;
    size_t suffix_size;
} MMTk_RubyBindingOptions;

typedef MMTk_ObjectReference (*MMTk_ObjectClosureFunction)(void*, void*, MMTk_ObjectReference, bool);

typedef struct MMTk_ObjectClosure {
    /**
     * The function to be called from C.
     */
    MMTk_ObjectClosureFunction c_function;
    /**
     * The pointer to the Rust-level closure object.
     */
    void *rust_closure;
} MMTk_ObjectClosure;

typedef struct MMTk_GCThreadTLS {
    int kind;
    void *gc_context;
    struct MMTk_ObjectClosure object_closure;
} MMTk_GCThreadTLS;

typedef struct MMTk_RubyUpcalls {
    void (*init_gc_worker_thread)(struct MMTk_GCThreadTLS *gc_worker_tls);
    struct MMTk_GCThreadTLS *(*get_gc_thread_tls)(void);
    bool (*is_mutator)(void);
    void (*stop_the_world)(MMTk_VMWorkerThread tls);
    void (*resume_mutators)(MMTk_VMWorkerThread tls);
    void (*block_for_gc)(MMTk_VMMutatorThread tls);
    size_t (*number_of_mutators)(void);
    void (*get_mutators)(void (*visit_mutator)(MMTk_Mutator*, void*), void *data);
    void (*scan_vm_roots)(void);
    void (*scan_finalizer_tbl_roots)(void);
    void (*scan_end_proc_roots)(void);
    void (*scan_global_tbl_roots)(void);
    void (*scan_obj_to_id_tbl_roots)(void);
    void (*scan_misc_roots)(void);
    void (*scan_final_jobs_roots)(void);
    void (*scan_roots_in_mutator_thread)(MMTk_VMMutatorThread mutator_tls,
                                         MMTk_VMWorkerThread worker_tls);
    void (*scan_object_ruby_style)(MMTk_ObjectReference object);
    void (*call_gc_mark_children)(MMTk_ObjectReference object);
    void (*call_obj_free)(MMTk_ObjectReference object);
    void (*cleanup_generic_iv_tbl)(void);
    void *(*get_original_givtbl)(MMTk_ObjectReference object);
    void (*move_givtbl)(MMTk_ObjectReference old_objref, MMTk_ObjectReference new_objref);
    size_t (*vm_live_bytes)(void);
    void (*update_frozen_strings_table)(void);
    void (*update_finalizer_table)(void);
    void (*update_obj_id_tables)(void);
    void (*update_global_symbols_table)(void);
    void (*update_overloaded_cme_table)(void);
    void (*update_ci_table)(void);
    struct MMTk_st_table *(*get_frozen_strings_table)(void);
    struct MMTk_st_table *(*get_finalizer_table)(void);
    struct MMTk_st_table *(*get_obj_id_tables)(void);
    struct MMTk_st_table *(*get_global_symbols_table)(void);
    struct MMTk_st_table *(*get_overloaded_cme_table)(void);
    struct MMTk_st_table *(*get_ci_table)(void);
    void (*st_get_size_info)(const struct MMTk_st_table *table,
                             size_t *entries_start,
                             size_t *entries_bound,
                             size_t *bins_num);
    void (*st_update_entries_range)(struct MMTk_st_table *table,
                                    size_t begin,
                                    size_t end,
                                    bool weak_keys,
                                    bool weak_records,
                                    bool forward);
    void (*st_update_bins_range)(struct MMTk_st_table *table, size_t begin, size_t end);
} MMTk_RubyUpcalls;

typedef struct MMTk_RawVecOfObjRef {
    MMTk_ObjectReference *ptr;
    size_t len;
    size_t capa;
} MMTk_RawVecOfObjRef;

MMTk_Builder *mmtk_builder_default(void);

void mmtk_init_binding(MMTk_Builder *builder,
                       const struct MMTk_RubyBindingOptions *_binding_options,
                       const struct MMTk_RubyUpcalls *upcalls);

MMTk_Mutator *mmtk_bind_mutator(MMTk_VMMutatorThread tls);

MMTk_Address mmtk_alloc(MMTk_Mutator *mutator,
                        size_t size,
                        size_t align,
                        size_t offset,
                        MMTk_AllocationSemantics semantics);

void mmtk_post_alloc(MMTk_Mutator *mutator,
                     MMTk_ObjectReference refer,
                     size_t bytes,
                     MMTk_AllocationSemantics semantics);

void mmtk_add_obj_free_candidate(MMTk_ObjectReference object);

void mmtk_enumerate_objects(void (*callback)(MMTk_ObjectReference, void*), void *data);

struct MMTk_RawVecOfObjRef mmtk_get_all_obj_free_candidates(void);

void mmtk_free_raw_vec_of_obj_ref(struct MMTk_RawVecOfObjRef raw_vec);

#endif /* MMTK_H */
